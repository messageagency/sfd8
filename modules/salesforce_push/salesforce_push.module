<?php

/**
 * @file
 * Push updates to Salesforce when a Drupal entity is updated.
 */

use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Entity\EntityInterface;
use Drupal\salesforce\EntityNotFoundException;
use Drupal\salesforce_mapping\Entity\MappedObject;
use Drupal\salesforce_mapping\Entity\MappedObjectInterface;
use Drupal\salesforce_mapping\Entity\SalesforceMapping;
use Drupal\salesforce_mapping\Entity\SalesforceMappingInterface;
use GuzzleHttp\Exception\RequestException;
use Drupal\salesforce_mapping\MappingConstants;
use Drupal\salesforce\SalesforceEvents;
use Drupal\salesforce_mapping\SalesforcePushEvent;

/**
 * Implements hook_entity_insert().
 */
function salesforce_push_entity_insert(EntityInterface $entity) {
  salesforce_push_entity_crud($entity, MappingConstants::SALESFORCE_MAPPING_SYNC_DRUPAL_CREATE);
}

/**
 * Implements hook_entity_update().
 */
function salesforce_push_entity_update(EntityInterface $entity) {
  salesforce_push_entity_crud($entity, MappingConstants::SALESFORCE_MAPPING_SYNC_DRUPAL_UPDATE);
}

/**
 * Implements hook_entity_delete().
 */
function salesforce_push_entity_delete(EntityInterface $entity) {
  salesforce_push_entity_crud($entity, MappingConstants::SALESFORCE_MAPPING_SYNC_DRUPAL_DELETE);
}

/**
 * Push entities to Salesforce.
 *
 * @param EntityInterface $entity
 *   The entity object.
 * @param string $op
 *   The trigger being responded to.
 *   One of push_create, push_update, push_delete.
 * @TODO
 *   at some point all these hook_entity_* implementations will go away. We'll
 *   create an event subscriber class to respond to entity events and delegate
 *   actions to the appropriate Push procedures. Unfortunately this point seems
 *   to be a very long ways away. https://www.drupal.org/node/2551893
 */
function salesforce_push_entity_crud(EntityInterface $entity, $op) {
  // Don't allow mapped objects or mappings to be pushed!
  if ($entity instanceof MappedObjectInterface
  || $entity instanceof SalesforceMappingInterface) {
    return;
  }

  try {
    $mappings = salesforce_push_load_push_mappings($entity->getEntityTypeId());
  }
  catch (EntityNotFoundException $e) {
    return;
  }

  foreach ($mappings as $mapping) {
    try {
      salesforce_push_entity_crud_mapping($entity, $op, $mapping);
    }
    catch (\Exception $e) {
      // Do not allow any exception to prevent entity CRUD.
      watchdog_exception('Salesforce Push', $e);
    }
  }
}

/**
 * Helper method for salesforce_push_entity_crud()
 *
 * @param EntityInterface $entity
 * @param string $op
 * @param SalesforceMappingInterface $mapping
 * @return void
 */
function salesforce_push_entity_crud_mapping(EntityInterface $entity, $op, SalesforceMappingInterface $mapping) {
  $mapped_objects = [];
  $mapped_object = null;
  // Event subscribers should throw an exception to prevent push.
  \Drupal::service('event_dispatcher')->dispatch(
    SalesforceEvents::PUSH_ALLOWED,
    new SalesforcePushEvent($mapped_object, NULL, $op)
  );

  // Look for existing mapped object or create a new one (except for deletes).
  $props = [
    'entity_id' => $entity->id(),
    'entity_type_id' => $entity->getEntityTypeId(),
    'salesforce_mapping' => $mapping->id(),
  ];

  try {
    $mapped_objects = \Drupal::service('entity.manager')
      ->getStorage('salesforce_mapped_object')
      ->throwExceptions()
      ->loadByProperties($props);
    // There should really only be one in this case, since we're loading on a
    // multi-field unique key, but loadByProperties returns an array.
    $mapped_object = current($mapped_objects);
  }
  catch (EntityNotFoundException $e) {
    // No mappings found.
    if ($op == MappingConstants::SALESFORCE_MAPPING_SYNC_DRUPAL_DELETE) {
      // If no existing mapping, and this is a delete, purge any entries from push queue and we're done.
      \Drupal::service('queue.salesforce_push')
        ->setName($mapping->id())
        ->deleteItemByEntity($entity);
      return;
    }
    $mapped_object = new MappedObject($props);
  }

  // Enqueue async push if the mapping is configured to do so, and quit.
  if ($mapping->async) {
    try {
      salesforce_push_enqueue_async($entity, $mapping, $mapped_object, $op);
    }
    catch (\Exception $e) {
      watchdog_exception('Salesforce Push', $e);
    }
    return;
  }

  // Attempt real-time push. Enqueue async push on failure.
  try {
    \Drupal::service('event_dispatcher')->dispatch(
      SalesforceEvents::PUSH_MAPPING_OBJECT,
      new SalesforcePushEvent($mapped_object, NULL, $op)
    );

    // If this is a delete, destroy the SF object.
    if ($op == MappingConstants::SALESFORCE_MAPPING_SYNC_DRUPAL_DELETE) {
      $mapped_object->pushDelete();
    }
    else {
      // Otherwise, push to SF. This also saves the mapped object.
      $mapped_object->push();
    }

    // On success, delete any push queue items for this entity.
    \Drupal::service('queue.salesforce_push')
      ->setName($mapping->id())
      ->deleteItemByEntity($entity);
  }
  catch (\Exception $e) {

    \Drupal::service('event_dispatcher')->dispatch(
      SalesforceEvents::PUSH_FAIL,
      new SalesforcePushEvent($mapped_object, NULL, $op)
    );

    watchdog_exception('Salesforce Push', $e);
    try {
      salesforce_push_enqueue_async($entity, $mapping, $mapped_object, $op);
    }
    catch (\Exception $e) {
      watchdog_exception('Salesforce Push', $e);
    }

    $mapped_object
      ->set('last_sync_action', $op)
      ->set('last_sync_status', FALSE)
      ->set('revision_log_message', $e->getMessage())
      ->save();
  }
}

/**
 * Helper function to load only those mappings which have at least one push
 * trigger enabled.
 *
 * @param $entity_type_id
 *   (optional) filter by mapping drupal entity type.
 *
 * @return array
 *
 * @throws EntityNotFoundException if no push mappings found.
 */
function salesforce_push_load_push_mappings($entity_type_id = NULL) {
  $push_mappings = [];
  $properties = empty($entity_type_id)
    ? []
    : ["drupal_entity_type" => $entity_type_id];
  $mappings = \Drupal::service('entity.manager')
    ->getStorage('salesforce_mapping')
    ->throwExceptions()
    ->loadByProperties($properties);

  foreach ($mappings as $key => $mapping) {
    if (!$mapping->doesPush()) {
      continue;
    }
    $push_mappings[$key] = $mapping;
  }
  if (empty($push_mappings)) {
    throw new EntityNotFoundException($properties, 'salesforce_mapping');
  }
  return $push_mappings;
}

/**
 * Worker function to insert a new queue item into the async push queue for the
 * given mapping.
 * @param EntityInterface $entity
 * @param SalesforceMappingInterface $mapping
 * @param string $op
 */
function salesforce_push_enqueue_async(EntityInterface $entity, SalesforceMappingInterface $mapping, MappedObjectInterface $mapped_object = NULL, $op) {
  // Each mapping has its own queue, so that like entries can be easily grouped
  // for batching. Each queue item is a unique array of entity ids to be
  // pushed. The async queue worker loads the queue item and works through as
  // many entities as possible, up to the async limit for this mapping.
  $props = [
    'name' => $mapping->id(),
    'entity_id' => $entity->id(),
    'op' => $op,
  ];
  if ($mapped_object) {
    $props['mapped_object_id'] = $mapped_object->id();
  }

  \Drupal::service('queue.salesforce_push')->createItem($props);
}

/**
 * Implements hook_cron().
 */
function salesforce_push_cron() {
  $queue = \Drupal::service('queue.salesforce_push');
  $queue->garbageCollection();
  try {
    $queue->processQueues();
  }
  catch (\Exception $e) {
    watchdog_exception('Salesforce Push', $e);
  }
}
